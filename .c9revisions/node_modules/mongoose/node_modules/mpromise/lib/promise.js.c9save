{"ts":1364394669830,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Module dependencies.\n */\n\nvar slice = require('sliced');\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * Promise constructor.\n *\n * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._\n *\n * @param {Function} back a function that accepts `fn(err, ...){}` as signature\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `reject`: Emits when the promise is rejected (event name may be overridden)\n * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)\n * @api public\n */\n\nfunction Promise (back) {\n  this.emitted = {};\n  this.ended = false;\n  if ('function' == typeof back)\n    this.onResolve(back);\n}\n\n/*!\n * event names\n */\n\nPromise.SUCCESS = 'fulfill';\nPromise.FAILURE = 'reject';\n\n/*!\n * Inherits from EventEmitter.\n */\n\nPromise.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Adds `listener` to the `event`.\n *\n * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.\n *\n * @param {String} event\n * @param {Function} callback\n * @return {Promise} this\n * @api public\n */\n\nPromise.prototype.on = function (event, callback) {\n  if (this.emitted[event])\n    callback.apply(this, this.emitted[event]);\n  else\n    EventEmitter.prototype.on.call(this, event, callback);\n\n  return this;\n}\n\n/**\n * Keeps track of emitted events to run them on `on`.\n *\n * @api private\n */\n\nPromise.prototype.emit = function (event) {\n  // ensures a promise can't be fulfill() or reject() more than once\n  var success = this.constructor.SUCCESS;\n  var failure = this.constructor.FAILURE;\n\n  if (event == success || event == failure) {\n    if (this.emitted[success] || this.emitted[failure]) {\n      return this;\n    }\n    this.emitted[event] = slice(arguments, 1);\n  }\n\n  return EventEmitter.prototype.emit.apply(this, arguments);\n}\n\n/**\n * Fulfills this promise with passed arguments.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n */\n\nPromise.prototype.fulfill = function () {\n  var args = slice(arguments);\n  return this.emit.apply(this, [this.constructor.SUCCESS].concat(args));\n}\n\n/**\n * Rejects this promise with `reason`.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n * @param {Object|String} reason\n * @return {Promise} this\n */\n\nPromise.prototype.reject = function (reason) {\n  return this.emit(this.constructor.FAILURE, reason);\n}\n\n/**\n * Resolves this promise to a rejected state if `err` is passed or\n * fulfilled state if no `err` is passed.\n *\n * @param {Error} [err] error or null\n * @param {Object} [val] value to fulfill the promise with\n * @api public\n */\n\nPromise.prototype.resolve = function (err, val) {\n  if (err) return this.reject(err);\n  return this.fulfill(val);\n}\n\n/**\n * Adds a listener to the SUCCESS event.\n *\n * @return {Promise} this\n * @api public\n */\n\nPromise.prototype.onFulfill = function (fn) {\n  return this.on(this.constructor.SUCCESS, fn);\n}\n\n/**\n * Adds a listener to the FAILURE event.\n *\n * @return {Promise} this\n * @api public\n */\n\nPromise.prototype.onReject = function (fn) {\n  return this.on(this.constructor.FAILURE, fn);\n}\n\n/**\n * Adds a single function as a listener to both SUCCESS and FAILURE.\n *\n * It will be executed with traditional node.js argument position:\n * function (err, args...) {}\n *\n * @param {Function} fn\n * @return {Promise} this\n */\n\nPromise.prototype.onResolve = function (fn) {\n  this.on(this.constructor.FAILURE, function(err){\n    fn.call(this, err);\n  });\n\n  this.on(this.constructor.SUCCESS, function(){\n    var args = slice(arguments);\n    fn.apply(this, [null].concat(args));\n  });\n\n  return this;\n}\n\n/**\n * Creates a new promise and returns it. If `onFulfill` or\n * `onReject` are passed, they are added as SUCCESS/ERROR callbacks\n * to this promise after the nextTick.\n *\n * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function (arg) {\n *       return arg + 1;\n *     }).then(function (arg) {\n *       throw new Error(arg + ' is an error!');\n *     }).then(null, function (err) {\n *       assert.ok(err instanceof Error);\n *       assert.equal('2 is an error', err.message);\n *     });\n *     p.complete(1);\n *\n * @see promises-A+ https://github.com/promises-aplus/promises-spec\n * @param {Function} onFulFill\n * @param {Function} onReject\n * @return {Promise} newPromise\n */\n\nPromise.prototype.then = function (onFulfill, onReject) {\n  var self = this\n    , retPromise = new Promise;\n\n  function handler (fn) {\n    return function handle (arg) {\n      var val;\n\n      try {\n        val = fn(arg);\n      } catch (err) {\n        if (retPromise.ended) throw err;\n        return retPromise.reject(err);\n      }\n\n      if (val && 'function' == typeof val.then) {\n        val.then(\n            retPromise.fulfill.bind(retPromise)\n          , retPromise.reject.bind(retPromise))\n      } else {\n        retPromise.fulfill(val);\n      }\n    }\n  }\n\n  process.nextTick(function () {\n    if ('function' == typeof onReject) {\n      self.onReject(handler(onReject));\n    } else {\n      self.onReject(retPromise.reject.bind(retPromise));\n    }\n\n    if ('function' == typeof onFulfill) {\n      self.onFulfill(handler(onFulfill));\n    } else {\n      self.onFulfill(retPromise.fulfill.bind(retPromise));\n    }\n  })\n\n  return retPromise;\n}\n\n/**\n * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n */\n\nPromise.prototype.end = function () {\n  this.ended = true;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Promise;\n"]],"start1":0,"start2":0,"length1":0,"length2":6631}]],"length":6631}
