{"ts":1364031096894,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Module dependencies.\n */\n\nvar STATES = require('./connectionstate')\n\n/**\n * Abstract Collection constructor\n *\n * This is the base class that drivers inherit from and implement.\n *\n * @param {String} name name of the collection\n * @param {Connection} conn A MongooseConnection instance\n * @param {Object} opts optional collection options\n * @api public\n */\n\nfunction Collection (name, conn, opts) {\n  if (undefined === opts) opts = {};\n  if (undefined === opts.capped) opts.capped = {};\n\n  opts.bufferCommands = undefined === opts.bufferCommands\n    ? true\n    : opts.bufferCommands;\n\n  if ('number' == typeof opts.capped) {\n    opts.capped = { size: opts.capped };\n  }\n\n  this.opts = opts;\n  this.name = name;\n  this.conn = conn;\n  this.queue = [];\n  this.buffer = this.opts.bufferCommands;\n\n  if (STATES.connected == this.conn.readyState) {\n    this.onOpen();\n  }\n};\n\n/**\n * The collection name\n *\n * @api public\n * @property name\n */\n\nCollection.prototype.name;\n\n/**\n * The Connection instance\n *\n * @api public\n * @property conn\n */\n\nCollection.prototype.conn;\n\n/**\n * Called when the database connects\n *\n * @api private\n */\n\nCollection.prototype.onOpen = function () {\n  var self = this;\n  this.buffer = false;\n  self.doQueue();\n};\n\n/**\n * Called when the database disconnects\n *\n * @api private\n */\n\nCollection.prototype.onClose = function () {\n  if (this.opts.bufferCommands) {\n    this.buffer = true;\n  }\n};\n\n/**\n * Queues a method for later execution when its\n * database connection opens.\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.addQueue = function (name, args) {\n  this.queue.push([name, args]);\n  return this;\n};\n\n/**\n * Executes all queued methods and clears the queue.\n *\n * @api private\n */\n\nCollection.prototype.doQueue = function () {\n  for (var i = 0, l = this.queue.length; i < l; i++){\n    this[this.queue[i][0]].apply(this, this.queue[i][1]);\n  }\n  this.queue = [];\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.ensureIndex = function(){\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findAndModify = function(){\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOne = function(){\n  throw new Error('Collection#findOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.find = function(){\n  throw new Error('Collection#find unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insert = function(){\n  throw new Error('Collection#insert unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.save = function(){\n  throw new Error('Collection#save unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.update = function(){\n  throw new Error('Collection#update unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.getIndexes = function(){\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.mapReduce = function(){\n  throw new Error('Collection#mapReduce unimplemented by driver');\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Collection;\n"]],"start1":0,"start2":0,"length1":0,"length2":3633}]],"length":3633}
