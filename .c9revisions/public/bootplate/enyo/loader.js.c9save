{"ts":1364886014002,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function() {\n\tenyo = window.enyo || {};\n\n\tenyo.pathResolverFactory = function() {\n\t\tthis.paths = {};\n\t};\n\n\tenyo.pathResolverFactory.prototype = {\n\t\taddPath: function(inName, inPath) {\n\t\t\treturn this.paths[inName] = inPath;\n\t\t},\n\t\taddPaths: function(inPaths) {\n\t\t\tif (inPaths) {\n\t\t\t\tfor (var n in inPaths) {\n\t\t\t\t\tthis.addPath(n, inPaths[n]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tincludeTrailingSlash: function(inPath) {\n\t\t\treturn (inPath && inPath.slice(-1) !== \"/\") ? inPath + \"/\" : inPath;\n\t\t},\n\t\t// match $name\n\t\trewritePattern: /\\$([^\\/\\\\]*)(\\/)?/g,\n\t\t// replace macros of the form $pathname with the mapped value of paths.pathname\n\t\trewrite: function (inPath) {\n\t\t\tvar working, its = this.includeTrailingSlash, paths = this.paths;\n\t\t\tvar fn = function(macro, name) {\n\t\t\t\tworking = true;\n\t\t\t\treturn its(paths[name]) || '';\n\t\t\t};\n\t\t\tvar result = inPath;\n\t\t\tdo {\n\t\t\t\tworking = false;\n\t\t\t\tresult = result.replace(this.rewritePattern, fn);\n\t\t\t} while (working);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tenyo.path = new enyo.pathResolverFactory();\n\n\tenyo.loaderFactory = function(inMachine, inPathResolver) {\n\t\tthis.machine = inMachine;\n\t\t// package information\n\t\tthis.packages = [];\n\t\t// module information\n\t\tthis.modules = [];\n\t\t// stylesheet paths\n\t\tthis.sheets = [];\n\t\t// (protected) internal dependency stack\n\t\tthis.stack = [];\n\t\tthis.pathResolver = inPathResolver || enyo.path;\n\t\tthis.packageName = \"\";\n\t\tthis.packageFolder = \"\";\n\t\tthis.finishCallbacks = {};\n\t};\n\n\tenyo.loaderFactory.prototype  = {\n\t\tverbose: false,\n\t\tloadScript: function(inScript) {\n\t\t\tthis.machine.script(inScript);\n\t\t},\n\t\tloadSheet: function(inSheet) {\n\t\t\tthis.machine.sheet(inSheet);\n\t\t},\n\t\tloadPackage: function(inPackage) {\n\t\t\tthis.machine.script(inPackage);\n\t\t},\n\t\treport: function() {\n\t\t},\n\t\t//\n\t\tload: function(/*<inDependency0, inDependency1 ...>*/) {\n\t\t\t// begin processing dependencies\n\t\t\tthis.more({\n\t\t\t\tindex: 0,\n\t\t\t\tdepends: arguments || []\n\t\t\t});\n\t\t},\n\t\tmore: function(inBlock) {\n\t\t\t// a 'block' is a dependency list with a bookmark\n\t\t\t// the bookmark (index) allows us to interrupt\n\t\t\t// processing and then continue asynchronously.\n\t\t\tif (inBlock) {\n\t\t\t\t// returns true if this block has asynchronous requirements\n\t\t\t\t// in that case, we unwind the stack. The asynchronous loader\n\t\t\t\t// must provide the continuation (by calling 'more' again).\n\t\t\t\tif (this.continueBlock(inBlock)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// A package is now complete. Pop the block that was interrupted for that package (if any).\n\t\t\tvar block = this.stack.pop();\n\t\t\tif (block) {\n\t\t\t\t// block.packageName is the name of the package that interrupted us\n\t\t\t\t//this.report(\"finished package\", block.packageName);\n\t\t\t\tif (this.verbose) {\n\t\t\t\t\tconsole.groupEnd(\"* finish package (\" + (block.packageName || \"anon\") + \")\");\n\t\t\t\t}\n\t\t\t\t// cache the folder for the currently processing package\n\t\t\t\tthis.packageFolder = block.folder;\n\t\t\t\t// no current package\n\t\t\t\tthis.packageName = \"\";\n\t\t\t\t// process this new block\n\t\t\t\tthis.more(block);\n\t\t\t} else {\n\t\t\t\tthis.finish();\n\t\t\t}\n\t\t},\n\t\tfinish: function() {\n\t\t\tthis.packageFolder = \"\";\n\t\t\tif (this.verbose) {\n\t\t\t\tconsole.log(\"-------------- fini\");\n\t\t\t}\n\t\t\tfor (var i in this.finishCallbacks) {\n\t\t\t\tif (this.finishCallbacks[i]) {\n\t\t\t\t\tthis.finishCallbacks[i]();\n\t\t\t\t\tthis.finishCallbacks[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcontinueBlock: function(inBlock) {\n\t\t\twhile (inBlock.index < inBlock.depends.length) {\n\t\t\t\tvar d = inBlock.depends[inBlock.index++];\n\t\t\t\tif (d) {\n\t\t\t\t\tif (typeof d == \"string\") {\n\t\t\t\t\t\tif (this.require(d, inBlock)) {\n\t\t\t\t\t\t\t// return true to indicate we need to interrupt\n\t\t\t\t\t\t\t// processing until asynchronous file load completes\n\t\t\t\t\t\t\t// the load process itself must provide the\n\t\t\t\t\t\t\t// continuation\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.pathResolver.addPaths(d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\trequire: function(inPath, inBlock) {\n\t\t\t// process aliases\n\t\t\tvar path = this.pathResolver.rewrite(inPath);\n\t\t\t// get path root\n\t\t\tvar prefix = this.getPathPrefix(inPath);\n\t\t\t// assemble path\n\t\t\tpath = prefix + path;\n\t\t\t// process path\n\t\t\tif ((path.slice(-4) == \".css\") || (path.slice(-5) == \".less\")) {\n\t\t\t\tif (this.verbose) {\n\t\t\t\t\tconsole.log(\"+ stylesheet: [\" + prefix + \"][\" + inPath + \"]\");\n\t\t\t\t}\n\t\t\t\tthis.requireStylesheet(path);\n\t\t\t} else if (path.slice(-3) == \".js\" && path.slice(-10) != \"package.js\") {\n\t\t\t\tif (this.verbose) {\n\t\t\t\t\tconsole.log(\"+ module: [\" + prefix + \"][\" + inPath + \"]\");\n\t\t\t\t}\n\t\t\t\tthis.requireScript(inPath, path);\n\t\t\t} else {\n\t\t\t\t// package\n\t\t\t\tthis.requirePackage(path, inBlock);\n\t\t\t\t// return true to indicate a package was located and\n\t\t\t\t// we need to interrupt further processing until it's completed\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tgetPathPrefix: function(inPath) {\n\t\t\tvar delim = inPath.slice(0, 1);\n\t\t\tif ((delim != \"/\") && (delim != \"\\\\\") && (delim != \"$\") && !/^https?:/i.test(inPath)) {\n\t\t\t\treturn this.packageFolder;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t},\n\t\trequireStylesheet: function(inPath) {\n\t\t\t// stylesheet\n\t\t\tthis.sheets.push(inPath);\n\t\t\tthis.loadSheet(inPath);\n\t\t},\n\t\trequireScript: function(inRawPath, inPath) {\n\t\t\t// script file\n\t\t\tthis.modules.push({\n\t\t\t\tpackageName: this.packageName,\n\t\t\t\trawPath: inRawPath,\n\t\t\t\tpath: inPath\n\t\t\t});\n\t\t\tthis.loadScript(inPath);\n\t\t},\n\t\tdecodePackagePath: function(inPath) {\n\t\t\t// A package path can be encoded in two ways:\n\t\t\t//\n\t\t\t//\t1. [folder]\n\t\t\t//\t2. [folder]/[*package.js]\n\t\t\t//\n\t\t\t// Note: manifest file name must end in \"package.js\"\n\t\t\t//\n\t\t\tvar alias = '', target = '', folder = '', manifest = 'package.js';\n\t\t\t// convert back slashes to forward slashes, remove double slashes, split on slash\n\t\t\tvar parts = inPath.replace(/\\\\/g, \"/\").replace(/\\/\\//g, \"/\").replace(/:\\//, \"://\").split(\"/\");\n\t\t\tvar i, p;\n\t\t\tif (parts.length) {\n\t\t\t\t// if inPath has a trailing slash, parts has an empty string which we pop off and ignore\n\t\t\t\tvar name = parts.pop() || parts.pop() || \"\";\n\t\t\t\t// test if name includes the manifest tag\n\t\t\t\tif (name.slice(-manifest.length) !== manifest) {\n\t\t\t\t\t// if not a manifest name, it's part of the folder path\n\t\t\t\t\tparts.push(name);\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise this is the manifest name\n\t\t\t\t\tmanifest = name;\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\tfolder = parts.join(\"/\");\n\t\t\t\tfolder = (folder ? folder + \"/\" : \"\");\n\t\t\t\tmanifest = folder + manifest;\n\t\t\t\t//\n\t\t\t\t// build friendly aliasing:\n\t\t\t\t//\n\t\t\t\tfor (i=parts.length-1; i >= 0; i--) {\n\t\t\t\t\tif (parts[i] == \"source\") {\n\t\t\t\t\t\tparts.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttarget = parts.join(\"/\");\n\t\t\t\t//\n\t\t\t\t// portable aliasing:\n\t\t\t\t//\n\t\t\t\t// packages that are rooted at a folder named \"enyo\" or \"lib\" do not\n\t\t\t\t// include that root path in their alias\n\t\t\t\t//\n\t\t\t\t//\tremove */lib or */enyo prefix\n\t\t\t\t//\n\t\t\t\t// e.g. foo/bar/baz/lib/zot -> zot package\n\t\t\t\t//\n\t\t\t\tfor (i=parts.length-1; (p=parts[i]); i--) {\n\t\t\t\t\tif (p == \"lib\" || p == \"enyo\") {\n\t\t\t\t\t\tparts = parts.slice(i+1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// remove \"..\" and \".\"\n\t\t\t\tfor (i=parts.length-1; (p=parts[i]); i--) {\n\t\t\t\t\tif (p == \"..\" || p == \".\") {\n\t\t\t\t\t\tparts.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\talias = parts.join(\"-\");\n\t\t\t}\n\t\t\treturn {\n\t\t\t\talias: alias,\n\t\t\t\ttarget: target,\n\t\t\t\tfolder: folder,\n\t\t\t\tmanifest: manifest\n\t\t\t};\n\t\t},\n\t\taliasPackage: function(inPath) {\n\t\t\tvar parts = this.decodePackagePath(inPath);\n\t\t\t// cache manifest path\n\t\t\tthis.manifest = parts.manifest;\n\t\t\t// cache package info for named packages\n\t\t\tif (parts.alias) {\n\t\t\t\t// debug only\n\t\t\t\t/*\n\t\t\t\tvar old = this.pathResolver.paths[parts.name];\n\t\t\t\tif (old && old != parts.folder) {\n\t\t\t\t\tthis.verbose && console.warn(\"mapping alias [\" + parts.name + \"] to [\" + parts.folder + \"] replacing [\" + old + \"]\");\n\t\t\t\t}\n\t\t\t\tthis.verbose && console.log(\"mapping alias [\" + parts.name + \"] to [\" + parts.folder + \"]\");\n\t\t\t\t*/\n\t\t\t\t//\n\t\t\t\t// create a path alias for this package\n\t\t\t\tthis.pathResolver.addPath(parts.alias, parts.target);\n\t\t\t\t//\n\t\t\t\t// cache current name\n\t\t\t\tthis.packageName = parts.alias;\n\t\t\t\t// cache package information\n\t\t\t\tthis.packages.push({\n\t\t\t\t\tname: parts.alias,\n\t\t\t\t\tfolder: parts.folder\n\t\t\t\t});\n\t\t\t}\n\t\t\t// cache current folder\n\t\t\tthis.packageFolder = parts.folder;\n\t\t},\n\t\trequirePackage: function(inPath, inBlock) {\n\t\t\t// cache the interrupted packageFolder\n\t\t\tinBlock.folder = this.packageFolder;\n\t\t\tthis.aliasPackage(inPath);\n\t\t\t// cache the name of the package 'inBlock' is loading now\n\t\t\tinBlock.packageName = this.packageName;\n\t\t\t// push inBlock on the continuation stack\n\t\t\tthis.stack.push(inBlock);\n\t\t\t// console/user reporting\n\t\t\tthis.report(\"loading package\", this.packageName);\n\t\t\tif (this.verbose) {\n\t\t\t\tconsole.group(\"* start package [\" + this.packageName + \"]\");\n\t\t\t}\n\t\t\t// load the actual package. the package MUST call a continuation function\n\t\t\t// or the process will halt.\n\t\t\tthis.loadPackage(this.manifest);\n\t\t}\n\t};\n})();"]],"start1":0,"start2":0,"length1":0,"length2":8716}]],"length":8716}
